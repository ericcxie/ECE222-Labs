; ECE-222 Lab ... Winter 2013 term 
; Lab 3 sample code 
				THUMB 		; Thumb instruction set 
                AREA 		My_code, CODE, READONLY
                EXPORT 		__MAIN
				ENTRY  
__MAIN

; The following lines are similar to Lab-1 but use a defined address to make it easier.
; They just turn off all LEDs 
				LDR			R10, =LED_BASE_ADR		; R10 is a permenant pointer to the base address for the LEDs, offset of 0x20 and 0x40 for the ports

				MOV 		R3, #0xB0000000		; Turn off three LEDs on port 1  
				STR 		R3, [r10, #0x20]
				MOV 		R3, #0x0000007C
				STR 		R3, [R10, #0x40] 	; Turn off five LEDs on port 2 

; This line is very important in your main program
; Initializes R11 to a 16-bit non-zero value and NOTHING else can write to R11 !!
				MOV			R11, #0xABCD		; Init the random number generator with a non-zero number
loop 			BL 			RandomNum 
				MOV			R9, #0 				; initialize counter

				
				B loop

;
; Display the number in R3 onto the 8 LEDs
DISPLAY_NUM		STMFD		R13!,{R1, R2, R14}

; Usefull commaands:  RBIT (reverse bits), BFC (bit field clear), LSR & LSL to shift bits left and right, ORR & AND and EOR for bitwise operations

				LDMFD		R13!,{R1, R2, R15}

;
; R11 holds a 16-bit random number via a pseudo-random sequence as per the Linear feedback shift register (Fibonacci) on WikiPedia
; R11 holds a non-zero 16-bit number.  If a zero is fed in the pseudo-random sequence will stay stuck at 0
; Take as many bits of R11 as you need.  If you take the lowest 4 bits then you get a number between 1 and 15.
;   If you take bits 5..1 you'll get a number between 0 and 15 (assuming you right shift by 1 bit).

; R11 MUST be initialized to a non-zero 16-bit value at the start of the program OR ELSE!
; R11 can be read anywhere in the code but must only be written to by this subroutine
RandomNum		STMFD		R13!,{R1, R2, R3, R14}

				AND			R1, R11, #0x8000
				AND			R2, R11, #0x2000
				LSL			R2, #2
				EOR			R3, R1, R2
				AND			R1, R11, #0x1000
				LSL			R1, #3
				EOR			R3, R3, R1
				AND			R1, R11, #0x0400
				LSL			R1, #5
				EOR			R3, R3, R1		; the new bit to go into the LSB is present
				LSR			R3, #15
				LSL			R11, #1
				ORR			R11, R11, R3
				
				LDMFD		R13!,{R1, R2, R3, R15}

Absolutely, here's an ARM assembly subroutine that scales the random number generated by RandomNum to the desired range of 20,000 to 100,000:

Code snippet
ScaleRandomNum STMFD   R13!, {R1, R2, R3}  ; Save registers used

; R0 = random number (assumed to be in R0 after calling RandomNum)

BIC  R2, R0, #0xF000  ; Clear upper 4 bits (keep 0-8 for modulo)
MOV  R1, #9          ; Set divisor (9)
UDIV R2, R2, R1      ; Unsigned division (remainder in R2)
ADD  R2, R2, #2      ; Add 2 to shift range to 2-10

MOV  R1, #10000       ; Set multiplier (10,000)
MUL  R0, R2, R1      ; Multiply by 10,000 to scale

LDMFD   R13!, {R1, R2, R3}  ; Restore registers used

; R0 now holds the scaled random number between 20,000 and 100,000
BX  LR                 ; Return from subroutine

;
;		Delay 0.1ms (100us) * R0 times
; 		aim for better than 10% accuracy
;               The formula to determine the number of loop cycles is equal to Clock speed x Delay time / (#clock cycles)
;               where clock speed = 4MHz and if you use the BNE or other conditional branch command, the #clock cycles =
;               2 if you take the branch, and 1 if you don't.

DELAY			STMFD		R13!,{R2, R14}
		;
		; code to generate a delay of 0.1mS * R0 times
		;
MultipleDelay	TEQ		R0,  #0		; test R0 to see if it's 0 - set Zero flag so you can use BEQ, BNE
				MOV 	R10, #0x85		; 133 in decimal
				
loop1
				SUBS 	R10, #1		; decrement counter R10 
				BNE 	loop1	
				SUBS 	R0, #1
				BEQ 	exitDelay
				BNE		MultipleDelay
exitDelay		LDMFD		R13!,{R2, R15}
				

LED_BASE_ADR	EQU 	0x2009c000 		; Base address of the memory that controls the LEDs 
PINSEL3			EQU 	0x4002c00c 		; Address of Pin Select Register 3 for P1[31:16]
PINSEL4			EQU 	0x4002c010 		; Address of Pin Select Register 4 for P2[15:0]
;	Usefull GPIO Registers
;	FIODIR  - register to set individual pins as input or output
;	FIOPIN  - register to read and write pins
;	FIOSET  - register to set I/O pins to 1 by writing a 1
;	FIOCLR  - register to clr I/O pins to 0 by writing a 1

				ALIGN 

				END 


; 1- If a 32-bit register is counting user reaction time in 0.1 milliseconds increments, what is the
; maximum amount of time which can be stored in 8 bits, 16-bits, 24-bits and 32-bits?

; 8 bits = (2^8 - 1) * 0.1 ms = 25.5 ms
; 16 bits -> 6553.5 ms
; 24 bits -> 1677721.5 ms
; 32 bits -> 429496729.5 ms

; 2- Considering typical human reaction time, which size would be the best for this task (8, 16,
; 24, or 32 bits)?

; According to Google, the typical human reaction time is around 250 milliseconds. 
; Therefore, 16 bits would be the best for this task since it can store up to 6553.5 ms whereas 8 bits can only store up to 25.5 ms.

; 3- Prove time delay meets 2 to 10 sec +/- 5% spec.

; 